类和接口
----------------------
- [类和接口](#类和接口)
  - [5.1 类和继承](#51-类和继承)
  - [5.2 super](#52-super)
  - [5.3 以this作为类型返回](#53-以this作为类型返回)
  - [5.4 接口](#54-接口)
    - [5.4.1 声明合并](#541-声明合并)
    - [5.4.2 实现](#542-实现)
    - [5.4.3 实现接口还是扩展抽象类](#543-实现接口还是扩展抽象类)
  - [5.5 类是结构化类型](#55-类是结构化类型)
  - [5.6 类既声明值也声明类型](#56-类既声明值也声明类型)
### 5.1 类和继承
### 5.2 super
- 方法调用
- 构造方法调用.此时使用特殊的形式super(),而且只能在构造方法中调用.如果子类有构造方法,在子类的构造方法中必须调用super(),把父子关系连接起来
  
super只能访问父类的方法,不能访问父类的属性

### 5.3 以this作为类型返回

对类来说,this类型还可用于注解方法的返回类型.

```typescript
class Set {
    has(value:number):boolean{

    }

    add(value:nuber):this{

    }
}
```
### 5.4 接口

类经常当作接口使用

类型别名和接口的区别
- 类型别名更通用,右边可以是任何类型,包括类型表达式;而在接口声明中,右边必须为结构.例如下面类型别名不能用接口重写:
``` typescript
type A:number 
type B:A|string

```
- 扩展接口时,TypeScript将检查扩展的接口是否可赋值给被扩展的接口.而使用交集类型时则不会出现这种问题.如果把前例中的接口换成类型别名,把extends换成交集运算符(&),TypeScript将尽自己所能,把扩展和被扩展的类型组合在一起,最终的结果是重载bad的签名,而不会抛出编译时错误
```typescript
interface A
{
    good(x: number): string
    bad(x:number):string
}

interface B extends A
{
    good(x: string | number): string,
    bad(x: string): string; // Error
}
```
- 同一作用域的多个同名接口将自动合并,同一个作用域中的多个类型别名将导致编译时错误.这个特性成为声明合并.

#### 5.4.1 声明合并

#### 5.4.2 实现
```typescript

interface Animal
{
    eat(food: string): void;
    sleep(hours: number): void;
}

class Catt implements Animal
{
    eat(food: string): void
    {
    
    }
    sleep(hours: number): void
    {
      
    }
}
```
Cat必须实现Animal声明的每个方法.如果需要还可以在此基础上实现其他方法和属性.

接口可以声明实例属性,但是不能带有可见性修饰符,也不能使用static关键字.

#### 5.4.3 实现接口还是扩展抽象类

实现接口其实与扩展抽象类差不多.区别是,接口更通用,更轻量,而抽象类的作用更具体,功能更丰富.

结构式对结构建模的方式吗.在值层面可以表示对象,数组,函数,类或类的实例,接口不生成代码,只存在于编译时.

抽象类只能对类建模,而且生成运行时代码,即JavaScript类.抽象类可以有构造方法,可以提供默认实现,还能为属性和方法设置访问修饰服.

### 5.5 类是结构化类型

与TypeScript中的其他类型一样,TypeScript根据结构比较类,与类的名称无关.

然而一个类中有使用private或protected修饰的字段,情况就不一样了.检查一个结构是否可赋值给一个类时,如果类中有private或protected字段,而且结构不是类或者其子类的实例,那么结构就不能赋值给类;
```typescript

class Cttt
{
    private x = 1;
}

function ff(c: Cttt)
{

}

ff({ x: 3 }) // Error
```
### 5.6 类既声明值也声明类型